import numpy as np
import math
from scipy.integrate import quad
import matplotlib.pyplot as plt

# Initializing a seed for reproducability
np.random.seed(5)

# Setting the global parameters
A = 14.1
s = 5.6

def f(x:float) -> float:
    """
    Defines the Lorentz distribution function.

    Args: x - The input to the function.

    Returns the value of the Lorentz distribution function at x.
    """
    return 4 / (x**2 + 4)

def gaussian(x:float, m:float, s:float) -> float:
    """
    Defines the Gaussian distribution function.

    Args:
        x - The input to the function.
        m - The mean of the Gaussian distribution.
        s - The standard deviation of the Gaussian distribution.

    Returns the value of the Gaussian distribution function at x.
    """
    return 1 / (np.sqrt(2 * np.pi) * s) * np.exp(-0.5 * ((x - m) / s)**2)

def generate_gaussian(m:float, s:float) -> float:
    """
    Generates a random number from a Gaussian distribution within a specific range.

    Args:
        m - The mean of the Gaussian distribution.
        s - The standard deviation of the Gaussian distribution.

    Returns a random number from the Gaussian distribution within the range -10 to 10.
    """
    while True:
        x = np.random.normal(m, s)
        if -10 < x < 10:
            return x

def cumulative_distribution_function(x:float) -> float:
    """
    Defines the cumulative distribution function (CDF) of the Lorentz distribution.

    Args:
        x - The input to the function.

    Returns the value of the CDF at x.
    """
    # Calculates the normalization constant for the Lorentz distribution
    norm_const, _ = quad(lambda x: f(x), -np.inf, np.inf)
    # print(f"Norm const.: {norm_const}") # To see normalization constant value

    # Integrates f(x) with respect to x
    integral, _ = quad(lambda x: f(x), -np.inf, x)
    return integral / norm_const

def inverse_cumulative_F(x:float) -> float:
    """
    Defines the inverse of the cumulative distribution function (CDF) of the Lorentz distribution.

    Args:
        x - The input to the function.

    Returns the value of the inverse CDF at x.
    """
    arctan_lo = math.atan(-5) # Arctan
    arctan_hi = math.atan(5)
    return 2 * math.tan(x * (arctan_hi - arctan_lo) + arctan_lo)

# Function to generate random numbers and collect them for analysis
def generate_random_numbers() -> tuple:
    """
    Generates random numbers using the analytical method and the combined analytical-rejection method.

    Returns two numpy arrays containing the generated random numbers.
    """
    analytical_x = []
    combined_x = []

    for i in range(1, 100001):
        
        # Inversion method
        u = np.random.random()
        x_1 = inverse_cumulative_F(u)
        analytical_x.append(x_1)

        # Combined analytical-rejection method
        while True:
            x_2 = generate_gaussian(0, s)
            y = np.random.random() * A * gaussian(x_2, 0, s)
            if y < f(x_2):
                combined_x.append(x_2)
                break

        if i % 10000 == 0:
            print(f"Generated {i} random numbers.. {x_1},    {x_2}")

    return np.array(analytical_x), np.array(combined_x)

def plot_histograms(analytical_x, combined_x) -> None:
    """
    Plots histograms of the generated random numbers.

    Args:
        analytical_x (np.array) - The random numbers generated by the analytical method.
        combined_x (np.array) - The random numbers generated by the combined method.
    """
    # Parameters
    num_bins = 100
    start = -11
    width = 22.0 / num_bins

    # Arrays to store histogram values
    bin_analytical = np.zeros(num_bins)
    bin_combined = np.zeros(num_bins)

    # Fill both histograms
    for x in analytical_x:
        ind = int((x - start) / width + 0.5)
        if ind >= 0 and ind < num_bins:
            bin_analytical[ind] += 1

    for x in combined_x:
        ind = int((x - start) / width + 0.5)
        if ind >= 0 and ind < num_bins:
            bin_combined[ind] += 1

    # Normalize histogram values
    a_max = np.max(bin_analytical)
    c_max = np.max(bin_combined)
    bin_analytical_normalized = bin_analytical / a_max
    bin_combined_normalized = bin_combined / c_max
    
    x_values = np.linspace(-20, 20, 1000)

    # Plot histograms
    plt.figure(figsize=(10, 6))
    plt.bar(np.arange(start, start + num_bins * width, width), bin_analytical_normalized, width=width, alpha=0.5, label='Analytical Method')
    plt.bar(np.arange(start, start + num_bins * width, width), bin_combined_normalized, width=width, alpha=0.5, label='Combined Method')
    
    plt.plot(x_values, f(x_values), label='f(x)', lw=2)
    plt.plot(x_values, A * gaussian(x_values, 0, s), label='g(x)', lw=2)
    plt.xlabel('$x$')
    plt.ylabel('$f(x)$')
    plt.title('Method Comparison')
    plt.legend()
    plt.grid(True)
    plt.show()

def plot_cumulative_distribution_function() -> None:
    """
    Plots the cumulative distribution function of the Lorentz distribution.
    """
    x_values = np.linspace(-10, 10, 1000)
    y_values = [cumulative_distribution_function(x) for x in x_values]

    plt.figure(figsize=(10, 6))
    plt.plot(x_values, y_values, label='CDF')
    plt.xlabel('x')
    plt.ylabel('Cumulative Probability')
    plt.title('Cumulative Distribution Function')
    plt.legend()
    plt.grid(True)
    plt.show()
    
def plot_hits_and_misses() -> None:
    """
    Plots the regions where the combined method hits and misses the target distribution.
    """
    x_values = np.linspace(-20, 20, 1000)
    f_values = f(x_values)
    g_values = A * gaussian(x_values, 0, s)

    plt.figure(figsize=(10, 6))
    plt.plot(x_values, f_values, label='f(x)', color='blue', lw=1)
    plt.fill_between(x_values, f_values, color='blue', alpha=0.3)
    plt.plot(x_values, g_values, label='g(x)', color='green', lw=1)
    plt.fill_between(x_values, g_values, color='green', alpha=0.3)
    plt.title('Hits and Misses of Combined Method')
    
    plt.text(0, 0.2, 'Hits', fontsize=12, color='blue', ha='center')
    plt.text(5, 0.9, 'Misses', fontsize=12, color='green', ha='center')
    plt.text(3, 0.6, 'f(x)', fontsize=12, color='blue', ha='center')
    plt.text(-7, 0.6, 'g(x)', fontsize=12, color='green', ha='center')
    
    plt.xticks([])
    plt.yticks([])
    
    plt.show()

if __name__ == "__main__":
    # Prints out generated random number values for analytical method & combined method
    analytical_x, combined_x = generate_random_numbers()

    # Plot histograms and makes comparisons
    plot_histograms(analytical_x, combined_x)

    # Plot cumulative distribution function
    plot_cumulative_distribution_function()
    
    # Plot hits and misses
    plot_hits_and_misses()